'use client';
// This file must be a client component because it uses hooks and state

import * as React from 'react';
import { useState, useEffect, useRef, useCallback } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { useAuth } from '@/context/AuthContext';
import { db, functionsInstance, storage } from '@/lib/firebaseConfig';
import { 
  collection, 
  query, 
  where, 
  orderBy, 
  getDocs, 
  addDoc, 
  serverTimestamp, 
  updateDoc, 
  doc, 
  deleteDoc, 
  Timestamp, 
  getDoc,
  writeBatch
} from 'firebase/firestore';
import { ref as storageRef, getMetadata } from 'firebase/storage';
import { httpsCallable } from 'firebase/functions';
import 'react-loading-skeleton/dist/skeleton.css';
import DocumentViewer from '@/components/dashboard/DocumentViewer';
import ChatInterface from '@/components/dashboard/ChatInterface'; // Import ChatInterface
import { FilesystemItem, MyDocumentData, FolderData, BreadcrumbItem } from '@/types'; 
import { formatBytes, cn } from '@/lib/utils'; 
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable";
import { 
  formatDistanceToNow, 
  parseISO, 
  isToday, 
  isYesterday, 
  isThisWeek, 
  isThisMonth, 
  format 
} from 'date-fns';
import { useToast } from "@/components/ui/use-toast"; 
import {
  ColumnDef,
  ColumnFiltersState,
  GroupingState,
  SortingState,
  VisibilityState,
  flexRender,
  getCoreRowModel,
  getFilteredRowModel,
  getGroupedRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  useReactTable,
  Row, 
  Column, 
  ExpandedState, 
  getExpandedRowModel, 
} from "@tanstack/react-table";
import {
  Dialog, 
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
  DropdownMenuRadioGroup, 
  DropdownMenuRadioItem, 
  DropdownMenuContent, // Re-add DropdownMenuContent import
} from "@/components/ui/dropdown-menu";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Skeleton } from "@/components/ui/skeleton"; 
import { ScrollArea } from "@/components/ui/scroll-area";
import { Checkbox } from "@/components/ui/checkbox";
import { ToggleGroup, ToggleGroupItem } from "@/components/ui/toggle-group"; 
import { ChevronDown, ChevronRight, Folder, File as FileIcon, MoreHorizontal, ArrowUpDown, Trash2, Edit, X, Check, Loader2, PlusCircle, Upload, FolderPlus, Minimize2, Maximize2, Eye, EyeOff, ListTree, List, LayoutGrid, RefreshCw } from "lucide-react";
import { DashboardClient } from '@/components/dashboard/DashboardClient';
import { DraggableRow } from '@/components/dashboard/DraggableRow';
import Breadcrumbs from '@/components/dashboard/Breadcrumbs'; // Import Breadcrumbs
import { FileUpload } from '@/components/dashboard/FileUpload'; // Import FileUpload (named export)
import { MoveDocumentModal } from '@/components/dashboard/MoveDocumentModal'; // Import MoveDocumentModal (named export)

interface DocumentTableProps {
  data: FilesystemItem[];
  isLoading: boolean;
  error: string | null;
  onSelectItem: (item: FilesystemItem | null) => void;
  onDeleteDocument: (docId: string) => Promise<void>;
  onFolderClick: (folderId: string, folderName: string) => void;
  onMoveClick: (itemId: string, itemName: string, itemType: 'document' | 'folder') => void;
  onRenameFolder: (folderId: string, currentName: string) => void;
  onDeleteFolder: (folderId: string, folderName: string) => void;
  initialGrouping?: GroupingState;
  onMoveRow: (dragIndex: number, hoverIndex: number) => void; 
  onDropItemIntoFolder: (itemId: string, targetFolderId: string) => void; 
}

const createColumns = (
  onSelectItem: (item: FilesystemItem | null) => void,
  onMoveClick: (itemId: string, itemName: string, itemType: 'document' | 'folder') => void,
  onRenameFolder: (folderId: string, currentName: string) => void,
  onFolderClick: (folderId: string, folderName: string) => void,
  handleDeleteClick: (item: FilesystemItem, e: React.MouseEvent) => void,
  isDeleting: boolean,
  deletingId: string | null
): ColumnDef<FilesystemItem>[] => {
  // Helper to get the appropriate icon based on item type and content type
  const getFileTypeIcon = (item: FilesystemItem) => {
    if (item.type === 'folder') {
      return <Folder className="h-4 w-4 mr-2 flex-shrink-0 text-sky-500" />;
    }

    const contentType = item.contentType?.toLowerCase() || '';
    const fileName = item.name?.toLowerCase() || '';

    if (contentType.startsWith('image/')) return <FileIcon className="h-4 w-4 mr-2 flex-shrink-0 text-purple-500" />;
    if (contentType.startsWith('video/')) return <FileIcon className="h-4 w-4 mr-2 flex-shrink-0 text-orange-500" />;
    if (contentType.startsWith('audio/')) return <FileIcon className="h-4 w-4 mr-2 flex-shrink-0 text-yellow-500" />;
    if (contentType === 'application/pdf') return <FileIcon className="h-4 w-4 mr-2 flex-shrink-0 text-red-500" />;
    if (contentType.includes('spreadsheet') || contentType.includes('excel') || fileName.endsWith('.xlsx') || fileName.endsWith('.xls') || fileName.endsWith('.csv')) return <FileIcon className="h-4 w-4 mr-2 flex-shrink-0 text-green-600" />;
    if (contentType.includes('word') || contentType.includes('document') || fileName.endsWith('.docx') || fileName.endsWith('.doc')) return <FileIcon className="h-4 w-4 mr-2 flex-shrink-0 text-blue-600" />;
    if (contentType.includes('presentation') || fileName.endsWith('.pptx') || fileName.endsWith('.ppt')) return <FileIcon className="h-4 w-4 mr-2 flex-shrink-0 text-orange-600" />; 
    if (contentType.includes('zip') || contentType.includes('archive') || fileName.endsWith('.zip') || fileName.endsWith('.rar') || fileName.endsWith('.7z')) return <FileIcon className="h-4 w-4 mr-2 flex-shrink-0 text-gray-500" />;
    if (contentType.includes('code') || contentType.startsWith('text/') || fileName.endsWith('.js') || fileName.endsWith('.ts') || fileName.endsWith('.py') || fileName.endsWith('.java') || fileName.endsWith('.html') || fileName.endsWith('.css')) return <FileIcon className="h-4 w-4 mr-2 flex-shrink-0 text-indigo-500" />;

    return <FileIcon className="h-4 w-4 mr-2 flex-shrink-0 text-gray-400" />; 
  };

  return [
    {
      accessorKey: 'name',
      header: ({ column }: { column: Column<FilesystemItem, unknown> }) => (
        <Button
          variant="ghost"
          onClick={() => column.toggleSorting(column.getIsSorted() === "asc")}
          className="-ml-4"
        >
          Name
          <ArrowUpDown className="ml-2 h-4 w-4" />
        </Button>
      ),
      cell: ({ row }: { row: Row<FilesystemItem> }) => {
        const item = row.original;
        const isSelected = false; 
        const icon = getFileTypeIcon(item);

        if (item.type === 'folder') {
          return (
            <button
              onClick={(e) => {
                e.stopPropagation(); 
                onSelectItem(null); 
                onFolderClick(item.id, item.name); 
              }}
              className={`flex items-center text-left w-full px-0 py-0 bg-transparent border-none cursor-pointer hover:underline ${isSelected ? 'font-semibold' : ''}`}
            >
              {icon}
              <span className="truncate">{item.name}</span>
            </button>
          );
        } else {
          return (
            <div
              onClick={() => onSelectItem(item)} 
              className={`flex items-center cursor-pointer ${isSelected ? 'font-semibold' : ''}`}
            >
              {icon}
              <span className="truncate">{item.name}</span>
            </div>
          );
        }
      },
    },
    {
      accessorKey: 'type',
      header: 'Type',
      cell: ({ row }: { row: Row<FilesystemItem> }) => {
        const item = row.original;
        if (item.type === 'folder') {
          return <span className="text-gray-600">Folder</span>;
        } else {
          const contentType = item.contentType || 'File';
          const simpleType = contentType.split('/').pop() || contentType; 
          return <span className="capitalize truncate text-gray-600">{simpleType}</span>;
        }
      },
      enableGrouping: true, 
      enableSorting: false, 
    },
    {
      accessorKey: 'size',
      header: 'Size',
      cell: ({ row }: { row: Row<FilesystemItem> }) => {
        const item = row.original;
        if (item.type === 'document') {
          return <span className="text-gray-600">{formatBytes(item.size)}</span>;
        } else {
          return <span className="text-gray-600">-</span>; 
        }
      },
      enableSorting: true, 
    },
    {
      accessorKey: 'updatedAt',
      header: 'Date Modified',
      cell: ({ row }: { row: Row<FilesystemItem> }) => {
        const item = row.original;
        if (!item.updatedAt) return <span>-</span>;

        let dateString: string;
        if (item.updatedAt instanceof Timestamp) {
          dateString = formatDistanceToNow(item.updatedAt.toDate(), { addSuffix: true });
        } else if (typeof item.updatedAt === 'string') {
          try {
            dateString = formatDistanceToNow(parseISO(item.updatedAt), { addSuffix: true });
          } catch {
            dateString = 'Invalid Date';
          }
        } else {
          dateString = '-';
        }

        return <span>{dateString}</span>;
      },
      meta: {
        className: 'hidden md:table-cell', 
      },
      enableGrouping: true, 
      getGroupingValue: (item: FilesystemItem) => { 
        if (!item.updatedAt) return 'Unknown Date';

        let date: Date;
        if (item.updatedAt instanceof Timestamp) {
          date = item.updatedAt.toDate();
        } else if (typeof item.updatedAt === 'string') {
          try {
            date = parseISO(item.updatedAt);
          } catch (e) {
            console.error("Error parsing date string:", item.updatedAt, e);
            return 'Invalid Date Format'; 
          }
        } else {
          return 'Unknown Date Type'; 
        }

        if (isNaN(date.getTime())) { 
             return 'Invalid Date Value'; 
        }

        const now = new Date();
        if (isToday(date)) return 'Today';
        if (isYesterday(date)) return 'Yesterday';
        if (isThisWeek(date, { weekStartsOn: 1 })) return 'This Week'; 
        if (isThisMonth(date)) return 'This Month';
        return format(date, 'yyyy'); 
      }, 
      enableSorting: true, 
    },
    {
      id: 'actions',
      header: () => <div className="text-right pr-2">Actions</div>, 
      cell: ({ row }: { row: Row<FilesystemItem> }) => {
        const item = row.original;
        return (
          <div className="text-right pr-2"> 
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button 
                  variant="ghost" 
                  size="icon" 
                  className="h-8 w-8" 
                  onClick={(e: React.MouseEvent) => e.stopPropagation()} 
                  data-testid={`actions-button-${item.id}`}
                >
                  <MoreHorizontal className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                {item.type === 'folder' ? (
                  <DropdownMenuItem onClick={(e: React.MouseEvent) => { e.stopPropagation(); onRenameFolder(item.id, item.name); }}>
                    <Edit className="mr-2 h-4 w-4" />
                    Rename
                  </DropdownMenuItem>
                ) : (
                  <DropdownMenuItem onClick={(e: React.MouseEvent) => { e.stopPropagation(); onSelectItem(item); }}>
                    <Eye className="mr-2 h-4 w-4" />
                    View
                  </DropdownMenuItem>
                )}
                <DropdownMenuItem onClick={(e: React.MouseEvent) => { e.stopPropagation(); onMoveClick(item.id, item.name, item.type); }}>
                  <FolderPlus className="mr-2 h-4 w-4" />
                  Move
                </DropdownMenuItem>
                <DropdownMenuItem 
                  className="text-red-600 focus:text-red-600 focus:bg-red-100"
                  onClick={(e: React.MouseEvent) => handleDeleteClick(item, e)} 
                  data-testid={`delete-button-${item.id}`}
                >
                  <Trash2 className="mr-2 h-4 w-4" />
                  Delete
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        );
      },
      enableHiding: false, 
      size: 100, 
    },
  ];
};

function DocumentTable({ 
  data, 
  isLoading, 
  error, 
  onSelectItem, 
  onDeleteDocument, 
  onFolderClick, 
  onMoveClick, 
  onRenameFolder, 
  onDeleteFolder, 
  initialGrouping, 
  onMoveRow, 
  onDropItemIntoFolder, 
}: DocumentTableProps) {
  const [itemToDelete, setItemToDelete] = useState<FilesystemItem | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);
  const [deletingId, setDeletingId] = useState<string | null>(null); 
  const [sorting, setSorting] = useState<SortingState>([]);
  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);
  const [columnVisibility, setColumnVisibility] = useState<VisibilityState>({});
  const [rowSelection, setRowSelection] = useState({});
  const [grouping, setGrouping] = useState<GroupingState>(initialGrouping ?? []); 
  const [expanded, setExpanded] = useState<ExpandedState>({}); 
  const { toast } = useToast();

  const handleDeleteClick = (item: FilesystemItem, e: React.MouseEvent) => {
    e.stopPropagation(); 
    setItemToDelete(item);
  };

  const columns = React.useMemo(
    () => createColumns(onSelectItem, onMoveClick, onRenameFolder, onFolderClick, handleDeleteClick, isDeleting, deletingId),
    [onSelectItem, onMoveClick, onRenameFolder, onFolderClick, handleDeleteClick, isDeleting, deletingId]
  );

  const table = useReactTable({
    data, 
    columns,
    getRowId: (originalRow) => originalRow.id, 
    onSortingChange: setSorting,
    onColumnFiltersChange: setColumnFilters,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getGroupedRowModel: getGroupedRowModel(), 
    getExpandedRowModel: getExpandedRowModel(), 
    onColumnVisibilityChange: setColumnVisibility,
    onRowSelectionChange: setRowSelection,
    onGroupingChange: setGrouping, 
    onExpandedChange: setExpanded, 
    state: {
      sorting,
      columnFilters,
      columnVisibility,
      rowSelection,
      grouping, 
      expanded, 
    },
  });

  const handleRowClick = (item: FilesystemItem) => {
    if (item.type === 'folder') {
      onFolderClick(item.id, item.name);
    } else {
      onSelectItem(item);
    }
  };

  if (isLoading) {
    return (
      <div className="space-y-2 flex-grow overflow-auto pr-2">
        {Array.from({ length: 8 }).map((_, index) => (
          <div key={index} className="flex items-center justify-between p-2 border rounded">
            <div className="flex items-center space-x-2 flex-grow">
              <Skeleton circle={true} height={24} width={24} />
              <Skeleton height={20} width={`80%`} />
            </div>
            <Skeleton height={20} width={60} />
          </div>
        ))}
      </div>
    );
  }

  if (error) {
    return <p className="text-red-500 p-4">Error loading items: {error}</p>;
  }

  return (
    <div className="flex flex-col flex-grow overflow-hidden h-full"> 
       {/* Column Toggle Button */}
       <div className="flex items-center py-2 justify-end flex-shrink-0 pr-2"> 
         <DropdownMenu>
           <DropdownMenuTrigger asChild>
             <Button variant="outline" className="ml-auto">
               Columns
             </Button>
           </DropdownMenuTrigger>
           <DropdownMenuContent align="end">
             {table
               .getAllColumns()
               .filter((column) => column.getCanHide())
               .map((column) => {
                 return (
                   <DropdownMenuCheckboxItem
                     key={column.id}
                     className="capitalize"
                     checked={column.getIsVisible()}
                     onCheckedChange={(value: boolean) =>
                       column.toggleVisibility(!!value)
                     }
                   >
                     {typeof column.columnDef.header === 'string' 
                        ? column.columnDef.header 
                        : column.id}
                   </DropdownMenuCheckboxItem>
                 );
               })}
           </DropdownMenuContent>
         </DropdownMenu>
       </div>

      {/* TanStack Table Rendering */} 
      <div className="rounded-md border flex-grow overflow-auto"> 
        <Table className="min-w-full">
          <TableHead className={cn("[&_tr]:border-b")}> 
            {table.getHeaderGroups().map((headerGroup) => ( 
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => {
                  const meta = header.column.columnDef.meta as { className?: string } | undefined;
                  return (
                    <TableHeader key={header.id} className={meta?.className}>
                      {header.isPlaceholder
                        ? null
                        : flexRender(
                            header.column.columnDef.header,
                            header.getContext()
                          )}
                    </TableHeader>
                  );
                })}
              </TableRow>
            ))}
          </TableHead> 
          <TableBody className={cn("[&_tr:last-child]:border-0")}> 
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => { 
                if (row.getIsGrouped()) {
                  return (
                    <TableRow key={row.id} className="bg-muted/50 hover:bg-muted/80 font-medium">
                      <TableCell colSpan={columns.length} className="py-2 px-4">
                        <div className="flex items-center gap-2">
                          <button
                            onClick={row.getToggleExpandedHandler()}
                            style={{ cursor: 'pointer' }}
                            className="p-1 rounded hover:bg-accent"
                          >
                            {row.getIsExpanded() ? (
                              <ChevronDown className="h-4 w-4" />
                            ) : (
                              <ChevronRight className="h-4 w-4" />
                            )}
                          </button>
                          <span>{String(row.groupingValue ?? 'Other')}</span>
                          <span className="text-xs text-muted-foreground">({row.subRows.length})</span>
                        </div>
                      </TableCell>
                    </TableRow>
                  );
                }
                
                if (!row.getIsGrouped() && (row.depth === 0 || row.getParentRow()?.getIsExpanded())) {
                  return (
                    <DraggableRow key={row.id} row={row} onMoveRow={onMoveRow} onDropItemIntoFolder={onDropItemIntoFolder}>
                      {row.getVisibleCells().map((cell) => (
                        <TableCell 
                          key={cell.id} 
                          className={cn(
                            (cell.column.columnDef.meta as { className?: string })?.className, 
                            {'cursor-pointer hover:bg-muted/50': cell.column.id !== 'actions' && cell.column.id !== 'select'},
                            {'bg-blue-100 dark:bg-blue-900': row.getIsSelected()} 
                          )}
                          style={{ width: cell.column.getSize() }} 
                          onClick={(e) => handleRowClick(row.original)} 
                        >
                          {flexRender(cell.column.columnDef.cell, cell.getContext())}
                        </TableCell>
                      ))}
                    </DraggableRow>
                  );
                }
                
                return null; 
              })
            ) : (
              <TableRow>
                <TableCell colSpan={columns.length} className="h-24 text-center">
                  No documents or folders found.
                </TableCell>
              </TableRow>
            )}
          </TableBody> 
        </Table>
      </div>

      {/* Delete Confirmation Dialog */}
      <Dialog open={itemToDelete !== null} onOpenChange={(open: boolean) => !open && setItemToDelete(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Are you absolutely sure?</DialogTitle>
            <DialogDescription>
              This action cannot be undone. This will permanently delete the {itemToDelete?.type === 'folder' ? 'folder' : 'document'}
              {' '}
              <span className="font-medium">'{itemToDelete?.name}'</span>.
              {itemToDelete?.type === 'folder' && ' All contents within this folder will also be deleted.'} 
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <DialogTrigger asChild>
              <Button variant="outline" onClick={() => setItemToDelete(null)} disabled={isDeleting}>Cancel</Button>
            </DialogTrigger>
            <DialogTrigger asChild>
              <Button onClick={() => {
              if (!itemToDelete) return;

              setDeletingId(itemToDelete.id);
              setIsDeleting(true);

              if (itemToDelete.type === 'document') {
                onDeleteDocument(itemToDelete.id)
                  .catch((error: unknown) => {
                    console.error(`Error deleting document ${itemToDelete.id}:`, error);
                    const message = error instanceof Error ? error.message : 'An unknown error occurred.';
                    toast({ variant: "destructive", title: "Error", description: `Failed to delete document '${itemToDelete.name}'. ${message}` });
                  })
                  .finally(() => {
                    setIsDeleting(false);
                    setItemToDelete(null); 
                  });
              } else if (itemToDelete.type === 'folder') {
                const deleteFolderFunction = httpsCallable(functionsInstance, 'deleteFolder');
                deleteFolderFunction({ folderId: itemToDelete.id })
                  .then((result) => {
                    const responseData = result.data as { success: boolean; message?: string };

                    if (responseData.success) {
                      toast({ title: "Success", description: `Folder '${itemToDelete.name}' and its contents deleted successfully.` });
                    } else {
                      throw new Error(responseData.message || 'Unknown error from function.');
                    }
                  })
                  .catch((error: unknown) => {
                    console.error(`Error calling deleteFolder function for ${itemToDelete.id}:`, error);
                    const message = error instanceof Error ? error.message : 'An unknown error occurred.';
                    toast({ variant: "destructive", title: "Error", description: `Failed to delete folder '${itemToDelete.name}'. ${message}` });
                  })
                  .finally(() => {
                    setIsDeleting(false);
                    setItemToDelete(null); 
                  });
              }
            }} disabled={isDeleting} className="bg-red-600 hover:bg-red-700">
              {isDeleting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
              Delete
            </Button>
            </DialogTrigger>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

// We're now using a separate DndProviderWrapper component

function DashboardPage() {
  const { user, loading: authLoading, logout } = useAuth();
  const router = useRouter();
  const { toast } = useToast();
  const [documents, setDocuments] = useState<MyDocumentData[]>([]);
  const [folders, setFolders] = useState<FolderData[]>([]);
  const [filesystemItems, setFilesystemItems] = useState<FilesystemItem[]>([]);
  const [currentFolderId, setCurrentFolderId] = useState<string | null>(null);
  const [folderPath, setFolderPath] = useState<BreadcrumbItem[]>([]); 
  const [selectedDocument, setSelectedDocument] = useState<MyDocumentData | null>(null);
  const [loadingDocs, setLoadingDocs] = useState(true);
  const [docsError, setDocsError] = useState<string | null>(null);
  const [isMaximized, setIsMaximized] = useState(false);
  const [isViewerVisible, setIsViewerVisible] = useState(true);
  const [showCreateFolderDialog, setShowCreateFolderDialog] = useState(false);
  const [newFolderName, setNewFolderName] = useState("");
  const [isCreatingFolder, setIsCreatingFolder] = useState(false);
  
  const [folderToRename, setFolderToRename] = useState<{id: string; currentName: string} | null>(null);
  const [newRenameFolderName, setNewRenameFolderName] = useState("");
  const [isRenamingFolder, setIsRenamingFolder] = useState(false);
  const [refreshTrigger, setRefreshTrigger] = useState(0);
  const [movingDocument, setMovingDocument] = useState<{ id: string; name: string } | null>(null);
  const [availableFolders, setAvailableFolders] = useState<FolderData[]>([]);
  const [isMoveModalOpen, setIsMoveModalOpen] = useState(false);
  const [isLoadingFolders, setIsLoadingFolders] = useState(false);
  const [viewMode, setViewMode] = useState<'list' | 'grid'>('list'); 
  const [isUploadDialogOpen, setIsUploadDialogOpen] = useState(false); 
  const [groupingOption, setGroupingOption] = useState<'type' | 'date' | 'none'>('none'); 

  const panelGroupRef = useRef<any>(null);

  const triggerRefresh = () => {
    setRefreshTrigger(prev => prev + 1);
  };

  async function fetchItems(folderId: string | null = null) {
    if (authLoading) {
      console.log('Auth is loading, skipping fetch.');
      return;
    }
    if (!user) {
      console.log('User not logged in, redirecting.');
      router.push('/login');
      return;
    }

    console.log(`Fetching items for user: ${user.uid}, folderId: ${currentFolderId}`);
    setLoadingDocs(true);
    setDocsError(null);
    setFilesystemItems([]);

    try {
      const userId = user.uid;

      const foldersQuery = query(
        collection(db, 'users', userId, 'folders'),
        where('parentFolderId', '==', currentFolderId),
        orderBy('name', 'asc')
      );
      const folderSnapshot = await getDocs(foldersQuery);
      const fetchedFolders: FolderData[] = folderSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
      } as FolderData));
      const folderItems: FilesystemItem[] = fetchedFolders.map(f => ({ ...f, type: 'folder' }));
      console.log('Fetched Folders:', fetchedFolders);

      let documentSnapshot;
      try {
        const documentsQueryByCreatedAt = query(
          collection(db, 'users', userId, 'documents'),
          where('folderId', '==', currentFolderId),
          orderBy('createdAt', 'desc') 
        );
        
        console.log('[Dashboard] Executing Firestore query for documents (sorted by createdAt)...');
        documentSnapshot = await getDocs(documentsQueryByCreatedAt);
        console.log('[Dashboard] Successfully retrieved documents sorted by creation date');
      } catch (indexError) {
        console.warn('[Dashboard] Index error, falling back to name sorting:', indexError);
        
        const documentsQueryByName = query(
          collection(db, 'users', userId, 'documents'),
          where('folderId', '==', currentFolderId),
          orderBy('name', 'asc')
        );
        
        console.log('[Dashboard] Falling back to name-based sorting query...');
        documentSnapshot = await getDocs(documentsQueryByName);
      }
      
      const fetchedDocs: MyDocumentData[] = documentSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        uploadedAt: doc.data().uploadedAt as Timestamp,
        createdAt: doc.data().createdAt as Timestamp,
        updatedAt: doc.data().updatedAt as Timestamp,
      } as MyDocumentData));
      const documentItems: FilesystemItem[] = fetchedDocs.map(d => ({ ...d, type: 'document' }));
      console.log(`[Dashboard] Processed ${fetchedDocs.length} documents into UI items`);

      const docsWithMetadata = await Promise.all(fetchedDocs.map(async (docData) => {
        let metadataProps: { size?: number; contentType?: string } = {};
        if (docData.storagePath) {
          try {
            const fileRef = storageRef(storage, docData.storagePath);
            const metadata = await getMetadata(fileRef);
            console.log(`[Dashboard] Fetched metadata for ${docData.name}: size=${metadata.size}, type=${metadata.contentType}`);
            metadataProps = { 
              size: metadata.size, 
              contentType: metadata.contentType 
            };
          } catch (error) {
            console.warn(`[Dashboard] Failed to get metadata for ${docData.name} (${docData.storagePath}):`, error);
          }
        } else {
          console.warn(`[Dashboard] Document ${docData.name} missing storagePath.`);
        }
        return { 
          ...docData, 
          ...metadataProps, 
          type: 'document' 
        } as FilesystemItem; 
      }));

      const combinedItems: FilesystemItem[] = [...folderItems, ...docsWithMetadata].sort((a, b) => {
        if (a.type === 'folder' && b.type !== 'folder') return -1;
        if (a.type !== 'folder' && b.type === 'folder') return 1;
        
        const nameA = a.name || '';
        const nameB = b.name || '';
        return nameA.localeCompare(nameB, undefined, { sensitivity: 'base' });
      });
      
      setFilesystemItems(combinedItems);
      console.log(`[Dashboard] Updated UI with ${combinedItems.length} total items (folders first, then sorted by name)`);

    } catch (error) {
      console.error('[Dashboard] Error fetching documents or folders:', error);
      setDocsError(`Failed to load items: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setLoadingDocs(false);
    }
  };

  const handleSelectDocument = (doc: MyDocumentData | null) => {
    console.log('Document selected:', doc);
    setSelectedDocument(doc);
    if (doc && !isViewerVisible) {
      setIsViewerVisible(true);
    }
  };

  const handleSelectItem = (item: FilesystemItem | null) => {
    if (item?.type === 'document') {
      handleSelectDocument(item);
    } else if (item?.type === 'folder') {
      console.log('Folder selected (for info):', item);
      setSelectedDocument(null);
    } else {
      handleSelectDocument(null);
    }
  };

  const handleFolderClick = useCallback((folderId: string, folderName: string) => {
    console.log(`Navigating into folder: ${folderName} (${folderId})`);
    setCurrentFolderId(folderId);
    setFolderPath(prev => [...prev, { id: folderId, name: folderName }]);
    setSelectedDocument(null);
  }, [setCurrentFolderId, setFolderPath]);

  const handleNavigate = useCallback((folderId: string | null) => {
    setSelectedDocument(null); 
    if (folderId === null) {
      router.push('/dashboard'); 
    } else {
      router.push(`/dashboard?folderId=${folderId}`); 
    }
  }, [router]);

  const handleBreadcrumbNavigate = useCallback((folderId: string) => {
    console.log(`Updating internal state for folder: ${folderId}`);
    if (folderId === 'root') {
      setFolderPath([]);
      setCurrentFolderId(null);
      setSelectedDocument(null);
    } else {
      const folderIndex = folderPath.findIndex(item => item.id === folderId);
      if (folderIndex !== -1) {
        setFolderPath(folderPath.slice(0, folderIndex + 1));
        setCurrentFolderId(folderId);
        setSelectedDocument(null);
      }
    }
  }, [folderPath, setCurrentFolderId, setFolderPath]);

  const handleUploadSuccess = () => {
    console.log("Upload complete signal received, refreshing current folder...");
    triggerRefresh();
    setIsUploadDialogOpen(false); 
  };

  const handleDeleteDocument = async (docId: string) => {
    if (!user) {
      console.error('No user available for deleting document');
      throw new Error('Authentication required');
    }
    
    let token: string | null = null;
    try {
      token = await user.getIdToken();
    } catch (tokenError) {
      console.error("Failed to get ID token for delete operation", tokenError);
      throw new Error('Authentication error. Please refresh and try again.');
    }
    
    console.log(`Attempting to delete document with ID: ${docId}`); 

    const response = await fetch(`/api/documents?id=${docId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });

    console.log('Delete API Response Status:', response.status); 

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ message: 'Failed to parse error response' })); 
      console.error('Delete API Error Response:', errorData); 
      throw new Error(errorData.message || `Failed to delete document. Status: ${response.status}`);
    }

    console.log('Document deleted successfully via API.'); 
    toast({ title: "Success", description: "Document deleted successfully." });

    await triggerRefresh(); 

  };

  const handleCreateFolder = async () => {
    if (!user) {
      toast({ variant: "destructive", title: "Error", description: "You must be logged in to create a folder." });
      return;
    }
    if (!newFolderName.trim()) {
      toast({ variant: "destructive", title: "Error", description: "Folder name cannot be empty." });
      return;
    }

    setIsCreatingFolder(true);
    try {
      const createFolderFunction = httpsCallable(functionsInstance, 'createFolder');
      await createFolderFunction({
        name: newFolderName.trim(),
        parentFolderId: currentFolderId
      });
      toast({ title: "Folder created", description: `Folder "${newFolderName.trim()}" created successfully.` });
      setShowCreateFolderDialog(false);
      setNewFolderName("");
      triggerRefresh();
    } catch (error) {
      console.error("Error creating folder:", error);
      toast({ variant: "destructive", title: "Error", description: `Failed to create folder: ${error instanceof Error ? error.message : 'Unknown error'}` });
    } finally {
      setIsCreatingFolder(false);
    }
  };

  async function fetchAllFolders() {
    if (!user) return;
    console.log(`Fetching all folders for user: ${user.uid}`);
    try {
      setIsLoadingFolders(true); 
      const foldersRef = collection(db, `users/${user.uid}/folders`);
      const q = query(foldersRef, orderBy('name', 'asc'));
      const querySnapshot = await getDocs(q);
      const fetchedFolders: FolderData[] = querySnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      } as FolderData));
      setAvailableFolders(fetchedFolders);
    } catch (error) {
      console.error('Error fetching all folders:', error);
      toast({ variant: "destructive", title: "Error", description: "Could not load folders for moving." });
      setAvailableFolders([]); 
    } finally {
      setIsLoadingFolders(false); 
    }
  };

  const handleOpenMoveModal = (itemId: string, itemName: string, itemType: 'document' | 'folder') => {
    if (availableFolders.length === 0) {
      fetchAllFolders(); 
    }
    setMovingDocument({ id: itemId, name: itemName });
    setIsMoveModalOpen(true);
  };

  const handleMoveConfirm = useCallback(async (targetFolderId: string | null) => {
    if (!movingDocument) return;

    console.log(`Attempting to move ${movingDocument.id} to ${targetFolderId}`);
    try {
      const moveDocFunc = httpsCallable(functionsInstance, 'moveDocument'); 
      await moveDocFunc({ 
        documentId: movingDocument.id, 
        targetFolderId: targetFolderId 
      });
      setIsMoveModalOpen(false); 
      setMovingDocument(null);
      toast({ title: "Success", description: `Moved '${movingDocument.name}' successfully.` });
      fetchAllFolders(); 
      fetchItems(currentFolderId); 
    } catch (error: any) {
      console.error("Error moving document:", error);
      const message = error?.details?.message || error?.message || 'An unknown error occurred';
      toast({ 
        variant: "destructive", 
        title: "Error Moving Document", 
        description: `Failed to move document: ${message}` 
      });
    }
  }, [
    movingDocument, 
    functionsInstance, 
    toast, 
    currentFolderId, 
    setIsMoveModalOpen, 
    setMovingDocument
  ]);

  const handleRenameFolder = (folderId: string, currentName: string) => {
    setFolderToRename({ id: folderId, currentName });
    setNewRenameFolderName(currentName); 
  };
  
  const confirmRenameFolder = async () => {
    if (!folderToRename || !newRenameFolderName.trim() || !user) return;
    
    setIsRenamingFolder(true);
    const { id, currentName } = folderToRename;
    const trimmedNewName = newRenameFolderName.trim();
    
    if (trimmedNewName === currentName) {
      setIsRenamingFolder(false);
      setFolderToRename(null);
      return;
    }
    
    try {
      const renameFolderFunction = httpsCallable<
        { folderId: string; newName: string },
        { success: boolean; message?: string }
      >(functionsInstance, 'renameFolder');
      
      const result = await renameFolderFunction({ 
        folderId: id, 
        newName: trimmedNewName 
      });
      
      const responseData = result.data as { success: boolean; message?: string };
      
      if (responseData.success) {
        toast({ 
          title: "Success", 
          description: `Folder renamed to '${trimmedNewName}' successfully.` 
        });
        
        setFolders(prev => prev.map(folder => 
          folder.id === id ? { ...folder, name: trimmedNewName } : folder
        ));
        
        if (currentFolderId === id) {
          setFolderPath(prev => prev.map(item => 
            item.id === id ? { ...item, name: trimmedNewName } : item
          ));
        }

        triggerRefresh();
      } else {
        throw new Error(responseData.message || 'Unknown error occurred');
      }
    } catch (error) {
      console.error(`Error renaming folder ${id}:`, error);
      const message = error instanceof Error ? error.message : 'An unknown error occurred';
      toast({ 
        variant: "destructive", 
        title: "Error", 
        description: `Failed to rename folder: ${message}` 
      });
    } finally {
      setIsRenamingFolder(false);
      setFolderToRename(null);
      setNewRenameFolderName("");
    }
  };

  const handleDeleteFolder = (folderId: string, folderName: string) => {
    console.log(`Delete folder requested: ${folderName} (${folderId})`);
  };

  const handleGroupingChange = (value: string) => { 
    setGroupingOption(value as 'type' | 'date' | 'none'); 
  };

  const handleMoveRow = useCallback((dragIndex: number, hoverIndex: number) => {
    setFilesystemItems((prevItems) => {
      const newItems = [...prevItems];
      const [draggedItem] = newItems.splice(dragIndex, 1);
      newItems.splice(hoverIndex, 0, draggedItem);
      return newItems;
    });
    console.log(`Moved item from index ${dragIndex} to ${hoverIndex} in local state.`);
  }, []); 

  const handleDropItemIntoFolder = useCallback(async (itemId: string, targetFolderId: string) => {
    console.log(`Attempting to move item ${itemId} into folder ${targetFolderId}`);
    const itemToMove = filesystemItems.find(item => item.id === itemId);

    if (!itemToMove) {
      toast({ variant: 'destructive', title: 'Error moving item', description: 'Could not find the item to move.' });
      return;
    }

    const collectionName = itemToMove.type === 'folder' ? 'folders' : 'documents';
    const itemRef = doc(db, collectionName, itemId);

    try {
      await updateDoc(itemRef, {
        parentId: targetFolderId,
        updatedAt: Timestamp.now(),
      });

      setFilesystemItems((prevItems) => prevItems.filter(item => item.id !== itemId));

      toast({ title: `Successfully moved ${itemToMove.type}`, description: `Moved '${itemToMove.name}' into target folder.` });
      console.log(`Successfully moved item ${itemId} to folder ${targetFolderId} in Firestore.`);
    } catch (error) {
      console.error("Error moving item into folder:", error);
      toast({ variant: 'destructive', title: 'Error Moving Item', description: 'Failed to update the item in the database.' });
    }
  }, [filesystemItems]); 

  useEffect(() => {
    if (authLoading) {
      console.log('Auth is loading, skipping fetch.');
      return;
    }
    if (!user) {
      console.log('User not logged in, redirecting.');
      router.push('/login');
      return;
    }

    console.log(`Fetching items for user: ${user.uid}, folderId: ${currentFolderId}`);
    setLoadingDocs(true);
    setDocsError(null);
    setFilesystemItems([]);

    fetchItems();

  }, [user, authLoading, router, currentFolderId, refreshTrigger, setLoadingDocs, setDocsError, setFilesystemItems]);

  if (authLoading) {
    return <div>Loading...</div>;
  }

  if (!user) {
    return <div>Loading...</div>;
  }

  return (
    <DashboardClient>
      <div className="flex h-screen flex-col bg-muted/40">
        <header className="sticky top-0 z-30 flex h-14 items-center gap-4 border-b bg-background px-4 sm:static sm:h-auto sm:border-0 sm:bg-transparent sm:px-6 py-4">
          <h1 className="text-xl font-semibold whitespace-nowrap">My Documents</h1>
          <div className="ml-auto flex items-center gap-4">
            <span className="text-sm text-muted-foreground whitespace-nowrap">Welcome, {user.displayName || user.email}</span>
            <Button variant="outline" size="sm" onClick={logout}>Logout</Button>
          </div>
        </header>

        <main className="flex-1 flex flex-col overflow-hidden">
          <div className="mb-4 text-sm text-muted-foreground">
            <Breadcrumbs path={folderPath} onNavigate={handleNavigate} />
          </div>

          <div className="flex h-full flex-col">
            {selectedDocument && (
              <div className="flex justify-end mb-2 gap-2">
                <Button 
                  variant="outline" 
                  size="sm" 
                  onClick={() => setIsMaximized(prev => !prev)}
                  title={isMaximized ? "Exit full screen" : "Full screen"}
                >
                  {isMaximized ? <Minimize2 className="h-4 w-4" /> : <Maximize2 className="h-4 w-4" />}
                </Button>
                <Button 
                  variant="outline" 
                  size="sm" 
                  onClick={() => setIsViewerVisible(prev => !prev)}
                  title={isViewerVisible ? "Hide document viewer" : "Show document viewer"}
                >
                  {isViewerVisible ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                </Button>
              </div>
            )}
            
            <div className="flex-1 rounded-lg border overflow-hidden">
              {isMaximized ? (
                <div className="h-full">
                  {selectedDocument ? (
                    <div className="flex h-full flex-col p-6 overflow-auto">
                      <div className="flex h-full flex-col">
                        <div className="flex-1 overflow-hidden">
                          {selectedDocument && <DocumentViewer document={selectedDocument}/>}
                        </div>
                      </div>
                    </div>
                  ) : (
                    <div className="flex h-full items-center justify-center text-muted-foreground">
                      Select a document to view.
                    </div>
                  )}
                </div>
              ) : (
                <div className="h-full">
                  {selectedDocument ? (
                    <ResizablePanelGroup direction="horizontal" className="h-full">
                      <ResizablePanel defaultSize={70} minSize={30} className="border-r">
                        <div className="flex h-full flex-col p-6 overflow-auto">
                          <div className="flex h-full flex-col">
                            <div className="flex-1 overflow-hidden">
                              {selectedDocument && <DocumentViewer document={selectedDocument}/>}
                            </div>
                          </div>
                        </div>
                      </ResizablePanel>
                      
                      <ResizableHandle withHandle />
                      
                      <ResizablePanel defaultSize={30} minSize={20}>
                        <div className="flex h-full flex-col p-6">
                          <ChatInterface documentId={selectedDocument.id} document={selectedDocument} />
                        </div>
                      </ResizablePanel>
                    </ResizablePanelGroup>
                  ) : (
                    <div className="flex h-full">
                      <div className="w-full">
                        <div className="flex h-full flex-col p-6 overflow-auto">
                        {/* Upload Dialog */}
                        <Dialog open={isUploadDialogOpen} onOpenChange={setIsUploadDialogOpen}>
                          <DialogTrigger asChild>
                            <Button variant="outline" size="sm">
                              <Upload className="h-4 w-4 mr-2" />
                              Upload Document
                            </Button>
                          </DialogTrigger>
                          <DialogContent className="sm:max-w-[525px]">
                            <DialogHeader>
                              <DialogTitle>Upload New Document</DialogTitle>
                              <DialogDescription>
                                Drag & drop files here or click to select. Files will be added to: <span className='font-medium'>{folderPath[folderPath.length - 1]?.name ?? 'Home'}</span>
                              </DialogDescription>
                            </DialogHeader>
                            <div className="pt-4 pb-0"> 
                              <FileUpload
                                onUploadComplete={handleUploadSuccess} 
                                currentFolderId={currentFolderId}
                              />
                            </div>
                            {/* Optional: Add explicit Close button if needed */}
                            {/* <DialogFooter>
                              <Button variant="outline" onClick={() => setIsUploadDialogOpen(false)}>Close</Button>
                            </DialogFooter> */}
                          </DialogContent>
                        </Dialog>
                        {/* Conditional Rendering for Document Table/Grid */}
                        <div className="flex justify-between items-center mb-4 flex-shrink-0">
                          <h2 className="text-xl font-semibold">Documents</h2>
                          <div className="flex items-center space-x-2">
                            {/* Grouping Control */}
                            <DropdownMenu>
                              <DropdownMenuTrigger asChild>
                                <Button variant="outline" size="sm">
                                  <ListTree className="h-4 w-4 mr-2" /> 
                                  Group: {groupingOption === 'type' ? 'Type' : groupingOption === 'date' ? 'Date' : 'None'}
                                </Button>
                              </DropdownMenuTrigger>
                              <DropdownMenuContent align="end">
                                <DropdownMenuLabel>Group By</DropdownMenuLabel>
                                <DropdownMenuSeparator />
                                <DropdownMenuRadioGroup value={groupingOption} onValueChange={handleGroupingChange}>
                                  <DropdownMenuRadioItem value="none">None</DropdownMenuRadioItem>
                                  <DropdownMenuRadioItem value="type">Type</DropdownMenuRadioItem>
                                  <DropdownMenuRadioItem value="date">Date</DropdownMenuRadioItem>
                                  {/* Add more grouping options here (e.g., date) */}
                                </DropdownMenuRadioGroup>
                              </DropdownMenuContent>
                            </DropdownMenu>
                            
                            {/* View Mode Toggle */}
                            <ToggleGroup 
                              type="single" 
                              defaultValue="list" 
                              value={viewMode}
                              onValueChange={(value: 'list' | 'grid') => {
                                if (value === 'list' || value === 'grid') {
                                  setViewMode(value);
                                }
                              }}
                              aria-label="View mode"
                            >
                              <ToggleGroupItem value="list" aria-label="List view">
                                <List className="h-4 w-4" />
                              </ToggleGroupItem>
                              <ToggleGroupItem value="grid" aria-label="Grid view">
                                <LayoutGrid className="h-4 w-4" />
                              </ToggleGroupItem>
                            </ToggleGroup>

                            <Button variant="outline" size="icon" onClick={triggerRefresh} title="Refresh Documents">
                              <RefreshCw className="h-4 w-4" />
                            </Button>
                          </div>
                        </div>
                        {loadingDocs ? (
                          <div className="flex items-center justify-center p-10">
                            <Loader2 className="h-6 w-6 animate-spin mr-2" />
                            <span>Loading items...</span>
                          </div>
                        ) : docsError ? (
                          <div className="text-red-600 p-4 text-center border border-red-300 rounded-md bg-red-50">
                            {docsError}
                          </div>
                        ) : (
                          <>
                            {viewMode === 'list' ? (
                              <DocumentTable 
                                data={filesystemItems}
                                isLoading={loadingDocs}
                                error={docsError}
                                onSelectItem={handleSelectItem} 
                                onDeleteDocument={handleDeleteDocument}
                                onFolderClick={handleFolderClick}
                                onMoveClick={handleOpenMoveModal} 
                                onRenameFolder={handleRenameFolder} 
                                onDeleteFolder={handleDeleteFolder} 
                                initialGrouping={ 
                                  groupingOption === 'type' ? ['type'] : 
                                  groupingOption === 'date' ? ['updatedAt'] : 
                                  [] 
                                } 
                                onMoveRow={handleMoveRow} 
                                onDropItemIntoFolder={handleDropItemIntoFolder}
                              />
                            ) : (
                              <DocumentGrid 
                                items={filesystemItems}
                                isLoading={loadingDocs}
                                error={docsError}
                                onSelectItem={handleSelectItem}
                                onFolderClick={handleFolderClick}
                                onDeleteDocument={handleDeleteDocument}
                                onDeleteFolder={handleDeleteFolder}
                                onMoveClick={handleOpenMoveModal} 
                                onRenameFolder={handleRenameFolder}
                              />
                            )}
                          </>
                        )}
                      </div>
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        </main>
      </div>
      <Dialog open={showCreateFolderDialog} onOpenChange={setShowCreateFolderDialog}>
        <DialogTrigger asChild>
          <Button variant="outline" size="sm" onClick={() => setShowCreateFolderDialog(true)}>
            <FolderPlus className="h-4 w-4 mr-2" />
            New Folder
          </Button>
        </DialogTrigger>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Create New Folder</DialogTitle>
            <DialogDescription>
              Enter a name for your new folder.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="folder-name" className="text-right">
                Name
              </Label>
              <Input 
                id="folder-name" 
                value={newFolderName} 
                onChange={(e: React.ChangeEvent<HTMLInputElement>) => setNewFolderName(e.target.value)} 
                className="col-span-3" 
                placeholder="My Project Files"
                disabled={isCreatingFolder}
              />
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowCreateFolderDialog(false)} disabled={isCreatingFolder}>Cancel</Button>
            <Button 
              type="button" 
              onClick={handleCreateFolder} 
              disabled={isCreatingFolder || !newFolderName.trim()}
            >
              {isCreatingFolder ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
              {isCreatingFolder ? 'Creating...' : 'Create Folder'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Rename Folder Dialog */}
      <Dialog open={!!folderToRename} onOpenChange={(open) => !open && setFolderToRename(null)}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Rename Folder</DialogTitle>
            <DialogDescription>
              Enter a new name for the folder "{folderToRename?.currentName}".
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="rename-folder-name" className="text-right">
                Name
              </Label>
              <Input
                id="rename-folder-name"
                value={newRenameFolderName}
                onChange={(e: React.ChangeEvent<HTMLInputElement>) => setNewRenameFolderName(e.target.value)}
                className="col-span-3"
                placeholder="Enter new folder name"
                autoFocus
                disabled={isRenamingFolder}
              />
            </div>
          </div>
          <DialogFooter>
            <Button 
              variant="outline" 
              onClick={() => setFolderToRename(null)} 
              disabled={isRenamingFolder}
            >
              Cancel
            </Button>
            <Button 
              type="button"
              onClick={confirmRenameFolder} 
              disabled={!newRenameFolderName.trim() || isRenamingFolder}
            >
              {isRenamingFolder ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Renaming...
                </>
              ) : (
                'Rename'
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Move Document Modal */}
      <MoveDocumentModal 
        isOpen={isMoveModalOpen}
        onClose={() => setIsMoveModalOpen(false)}
        documentName={movingDocument?.name || ''}
        folders={availableFolders} 
        onConfirmMove={handleMoveConfirm} 
        isLoadingFolders={isLoadingFolders}
      />
      </div>
    </DashboardClient>
  );
}

export default DashboardPage;
